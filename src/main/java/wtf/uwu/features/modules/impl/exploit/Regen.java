package wtf.uwu.features.modules.impl.exploit;

import net.minecraft.client.gui.ScaledResolution;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.network.play.client.C03PacketPlayer.C04PacketPlayerPosition;
import wtf.uwu.events.annotations.EventTarget;
import wtf.uwu.events.impl.packet.PacketEvent;
import wtf.uwu.events.impl.player.UpdateEvent;
import wtf.uwu.events.impl.render.Render2DEvent;
import wtf.uwu.features.modules.Module;
import wtf.uwu.features.modules.ModuleCategory;
import wtf.uwu.features.modules.ModuleInfo;
import wtf.uwu.features.modules.impl.visual.Interface;
import wtf.uwu.features.values.impl.BoolValue;
import wtf.uwu.features.values.impl.SliderValue;
import wtf.uwu.gui.font.Fonts;
import wtf.uwu.utils.animations.ContinualAnimation;
import wtf.uwu.utils.math.TimerUtils;
import wtf.uwu.utils.packet.BadPacketsComponent;
import wtf.uwu.utils.render.RoundedUtils;

import java.awt.Color;
import java.text.DecimalFormat;

@ModuleInfo(name = "Regen", category = ModuleCategory.Exploit)
public class Regen extends Module {

    private final SliderValue packets = new SliderValue("Packets", 20, 1, 100, 1, this);
    private final SliderValue maxBalance = new SliderValue("Max Balance", 3000, 500, 10000, 100, this);
    private final BoolValue onlyWhenStill = new BoolValue("Only Still", true, this);
    private final BoolValue showIndicator = new BoolValue("Show Indicator", true, this);

    private double balance = 0;
    private boolean isRegenerating = false;
    private final TimerUtils timerUtils = new TimerUtils();
    private final double PACKET_COST_PER_BURST = 50;

    private final ContinualAnimation animation = new ContinualAnimation();

    @Override
    public void onEnable() {
        reset();
    }

    @Override
    public void onDisable() {
        reset();
    }

    @EventTarget
    public void onPacket(PacketEvent event) {
        if (event.getState() != PacketEvent.State.OUTGOING || !(event.getPacket() instanceof C03PacketPlayer)) {
            return;
        }

        C03PacketPlayer c03 = (C03PacketPlayer) event.getPacket();

        boolean shouldCancel = !c03.getRotating() && !c03.isMoving() && !BadPacketsComponent.bad() &&
                (!onlyWhenStill.get() || isPlayerStill());

        if (shouldCancel) {
            event.setCancelled(true);
        }

        if (!event.isCancelled()) {
            this.balance -= 50;
        }

        this.balance += timerUtils.getTime();
        this.timerUtils.reset();
    }

    @EventTarget
    public void onUpdate(UpdateEvent event) {
        if (mc.thePlayer == null || mc.theWorld == null) return;

        setTag(String.valueOf((int) packets.get()));

        if (balance >= maxBalance.get()) {
            isRegenerating = true;
        }

        if (balance <= 0) {
            isRegenerating = false;
            balance = 0;
        }

        boolean canRegen = mc.thePlayer.getHealth() < mc.thePlayer.getMaxHealth() &&
                mc.thePlayer.getFoodStats().getFoodLevel() >= 18 &&
                mc.thePlayer.onGround &&
                !mc.thePlayer.isPotionActive(19) &&
                !mc.thePlayer.isPotionActive(20);

        if (isRegenerating && canRegen) {
            for (int i = 0; i < packets.get(); i++) {
                mc.getNetHandler().addToSendQueue(new C04PacketPlayerPosition(
                        mc.thePlayer.posX,
                        mc.thePlayer.posY,
                        mc.thePlayer.posZ,
                        true
                ));
            }

            balance -= PACKET_COST_PER_BURST;
        }

        if (balance > maxBalance.get()) {
            balance = maxBalance.get();
        }
    }

    @EventTarget
    public void onRender2D(Render2DEvent event) {
        if (!showIndicator.get()) return;

        final ScaledResolution resolution = new ScaledResolution(mc);
        final int x = resolution.getScaledWidth() / 2;
        final int y = resolution.getScaledHeight() - 75;
        final float thickness = 5F;

        float percentage = (float) (balance / maxBalance.get());
        percentage = Math.max(0.0f, Math.min(1.0f, percentage));

        final int width = 100;
        final int half = width / 2;
        animation.animate((width - 2) * percentage, 40);

        Interface interfaceModule = getModule(Interface.class);
        RoundedUtils.drawRound(x - half - 1, y - 1 - 12, width + 1, (int) (thickness + 1) + 12 + 3, 2, new Color(interfaceModule.bgColor(), true));
        RoundedUtils.drawRound(x - half - 1, y - 1, width + 1, (int) (thickness + 1), 2, new Color(interfaceModule.bgColor(), true));
        RoundedUtils.drawGradientHorizontal(x - half, y, animation.getOutput(), thickness, 2, new Color(interfaceModule.color(0)), new Color(interfaceModule.color(90)));

        Fonts.interRegular.get(15).drawCenteredString("Regen Balance", x, y - 1 - 11 + 3, -1);
        Fonts.interRegular.get(12).drawCenteredString(new DecimalFormat("0.0").format(percentage * 100) + "%", x, y + 2, -1);
    }

    private boolean isPlayerStill() {
        return mc.thePlayer.motionX == 0 && mc.thePlayer.motionZ == 0;
    }

    private void reset() {
        this.balance = 0;
        this.isRegenerating = false;
        this.timerUtils.reset();
    }
}